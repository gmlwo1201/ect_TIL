# 알고리즘 이해 기말고사
- 코딩 70%, 이론 30%, 10문제
- 알고리즘 1강 2차시 Big O 표현 시험범위
- 너비, 깊이 우선 탐색 이론
- 5강 2차시 버블, 쉘 등 4가지 정렬까지

## 너비 우선 탐색
* 선입선출 방식 - **큐**

## 깊이 우선 탐색
* 스택 자료구조 이용
* 재귀 함수로 구현

## 버블 정렬
* 이웃하는 숫자 비교해 작은 수 앞쪽으로 이동시키는 과정 반복해 정렬하는 알고리즘
```python
for pass = 1 to n-1
  for i = 1 to n-pass
    if (A[i-1] > A[i]) // 위의 원소가 아래의 원소보다 크면
      A[i-1] ↔ A[i] // 서로 자리를 바꾼다.
return 배열 A
```
* 총 비교 횟수: n(n-1)/2
* 시간 복잡도: O(n^2)

## 선택 정렬
* 입력 배열 전체에서 최소값 선택해 배열의 0번 원소와 자리 바꿈
* 0번 원소 제외 최소값 선택에 1번 원소와 자리 바꿈 > 반복해서 정렬
```python
for i = 0 to n-2 {
  min = i
  for j = i+1 to n-1 { // A[i]~A[n-1]에서 최솟값을 찾는다.
    if (A[j] < A[min])
      min = j
  }
  A[i] ↔ A[min] // min이 최솟값이 있는 원소의 인덱스
}
return 배열 A
```
* 총 비교 횟수: n(n-1)/2
* 시간 복잡도: O(n^2) - 항상 일정한 시간 복잡도 나타냄

## 삽입 정렬
* 배열을 정렬된 부분 (앞부분)과 정렬 안 된 부분 (뒷부분)으로 나눔
* 정렬 안 된 부분 가장 앞 원소 정렬한 부분의 적절한 위치에 삽입
```python
for i = 1 to n-1 {
  CurrentElement = A[i] // 정렬 안된 부분의 가장 왼쪽 원소

  j ← i – 1 // 정렬된 부분의 가장 오른쪽 원소로부터 왼쪽 방향으로 삽입할 곳을 탐색하기 위하여

  while (j >= 0) and (A[j] > CurrentElement) {
    A[j+1] = A[j] // 자리 이동
    j ← j -1
  }
  A [j+1] ← CurrentElement
}
return A
```
* 총 비교 횟수: n(n-1)/2
* 시간 복잡도: O(n^2) - 입력이 이미 정렬되어 있다면 시간 복잡도 O(n), 역으로 정렬될 경우 O(n^2)

## 쉘 정렬
* 버블 정렬 이용해 이웃하는 원소끼리의 자리이동으로 원소들 정렬
* 삽입 정렬 이용해 배열 뒷부분 작은 숫자 빠르게 앞으로 이동, 앞부분 큰 숫자는 뒷부분으로 이동
```python
for each gap h = [ h0 > h1 > ... > hk=1] // 큰 gap부터 차례로
  for i = h to n-1 {
    CurrentElement=A[i];
    j = i;
    while (j>=h) and (A[j-h]>CurrentElement) {
      A[j]=A[j-h];
      j=j-h;
    }
    A[j]=CurrentElement;
  }
return 배열 A
```
* 시간 복잡도: 최악의 경우 O(n^2)
* 2^k-1을 사용하면 O(n^1.5)-아직 확실 X

## O(Big-Oh)-표기
* 최악의 경우의 알고리즘 수행시간을 표현 - 점근적 상한 수행시간
* 가장 많이 사용하는 알고리즘 성능 표기법
* 표기 방법
  - n개의 숫자가 있는 경우 임의의 숫자 찾기 위한 순차탐색 최악 경우 시간 복잡도 = O(n)
  - 함수가 있으면 최고차항 사용

## Ω(Big-Omega)–표기
* 수행해야 하는 최소한의 수행시간 - 점근적 하한
* 표기 방법
  - O-표기와 마찬가지로 최고차항 사용

## Θ(Theta)–표기
* O 표기법(점근적 상한)과 Ω 표기법(점근적 하한)을 모두 만족시키는 증가 함수
* O-표기와 Ω-표기가 같은 경우에 사용
* 동일한 증가율 의미

# 코드 모음
## 
